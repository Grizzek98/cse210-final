import arcade
from arcade.sprite_list.sprite_list import SpriteList
from game.floating_object import FloatingObject
from game.script import GameScript
from game import enemy
from game import spawn
from game.weapon import Projectile
from random import randint

class EnemyService():
    """handles enemy lists and generation of new enemies according to script.
    To add enemies to the game, create a list for it and a dict entry linking the object type
    to the list, and a dict entry linking the enemy type to it's spawner.
    You will also have to modify script to set the conditions for the enemy's spawn.

    attributes: 
        asteroid_list (SpriteList), list of all basic asteroids
        time_elapsed (float), time since last spawn event
        enemy_list_map (dict), maps enemy_types to enemylists
        enemy_list_map (dict), maps enemy_types to Spawn objects
        add_score (int), score to add since last frame"""

    def __init__(self):
        self.asteroid_list = arcade.SpriteList()
        self.misc_list = arcade.SpriteList() #for enemies spawned by enemies
        self.enemy_list_map = {
            enemy.Asteroid : self.asteroid_list,
            FloatingObject : self.misc_list
        }
        self.enemy_spawn_map = {enemy.Asteroid : spawn.SpawnAsteroid}
        self.time_elapsed = 0 #time since last spawn
        self.add_score = 0
        #TODO should package all lists for draw() method 
        #TODO return score

    def update_sprites(self, delta_time: float, projectile_list: SpriteList) -> SpriteList:
        """Call the on_update() method for every sprite in the enemy list.
        Catch any returns and add them to the sprite list as needed.
        args:
            delta_time (float) time since last frame
            projectile_list (SpriteList) list of projectiles generated by enemies this update"""
        
        for value in self.enemy_list_map.values():
            for enemy in value :
                return_catch = enemy.on_update(delta_time)
                if return_catch is None :
                    pass
                elif isinstance(return_catch, Projectile):
                    projectile_list.append(return_catch)
                    #TODO multi firing enemies will be broken. Does not discriminate between list of enemies and list of projectiles.
                    #projectiles will not be treated as projectiles.
                elif isinstance(return_catch, arcade.SpriteList):
                    self.enemy_list.extend(return_catch)
                elif isinstance(return_catch, arcade.Sprite):
                    self.enemy_list.append(return_catch)
                else :
                    print("EnemyService does not know sprite.on_update return type. Perhaps you used List instead of SpriteList?")
                    print("this: ", enemy)
                    print("returned this: ", return_catch)
                    raise TypeError
        return projectile_list

    def _get_unfilled_spawns(self, script: GameScript) -> list:
        """return a list of enemies that need spawning associated with the number that can spawn"""
        spawnable_enemies = []
        for enemy_type in script.allowed_enemies :
            if len(self.enemy_list_map[enemy_type[0]]) < enemy_type[1] :
                spawnable_enemies.append(enemy_type)
        if len(spawnable_enemies) == 0:
            return None
        else : 
            return spawnable_enemies
                

    def _spawn_enemy(self, can_spawn: list, num_spawn: int):
        """spawn a random enemy from the list of allowed enemies and add it to it's list"""
        for x in range(1, num_spawn):
            index = 0
            spawner = self.enemy_spawn_map[can_spawn[index][0]]()
            self.enemy_list_map[can_spawn[index][0]].append(spawner.spawn())
        self.time_elapsed = 0

    def _get_num_spawn(self, script: GameScript) -> int:
        """return number of spawnable entities"""
        return int(self.time_elapsed / script.enemy_spawn_rate)

    def _handle_enemy_creation(self, script: GameScript):
        """check how many entities can spawn and spawn that number"""
        num_spawn = self._get_num_spawn(script)
        if num_spawn > 0:
            can_spawn = self._get_unfilled_spawns(script)
            if can_spawn :
                for x in range(1, num_spawn):
                    self._spawn_enemy(can_spawn, num_spawn)
            else :
                self.time_elapsed = 0

    def _check_remove_bounds(self):
        """Remove any out of bounds objects"""
        for value in self.enemy_list_map.values():
            for sprite in value:
                if sprite.check_bounds_x() or sprite.check_bounds_y():
                    value.remove(sprite)

    def _check_remove_HP(self) -> int: #int is score
        """Remove any destroyed objects and return their score given"""
        score = 0
        for value in self.enemy_list_map.values():
            for sprite in value:
                if sprite.get_hit_points() <= 0:
                    value.remove(sprite)
                    score += sprite.score_given
        return score

    def on_update(self, script: GameScript, delta_time: float) -> arcade.SpriteList:
        self.add_score = 0
        self.time_elapsed += delta_time
        projectile_list = arcade.SpriteList()
        projectile_list = self.update_sprites(delta_time, projectile_list)
        self._check_remove_bounds()
        self.add_score = self._check_remove_HP()
        self._handle_enemy_creation(script)

        len(self.enemy_list_map.values())
        return projectile_list

    def get_all_enemies(self):
        return list(self.enemy_list_map.values())